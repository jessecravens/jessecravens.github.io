<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: IndexedDB | Jesse Cravens]]></title>
  <link href="http://jessecravens.com/blog/categories/indexeddb/atom.xml" rel="self"/>
  <link href="http://jessecravens.com/"/>
  <updated>2013-02-03T23:52:21-06:00</updated>
  <id>http://jessecravens.com/</id>
  <author>
    <name><![CDATA[Jesse Cravens]]></name>
    <email><![CDATA[jesse.cravens@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[HTML5.tx 2013]]></title>
    <link href="http://jessecravens.com/blog/2013/02/03/html5-dot-tx-2013/"/>
    <updated>2013-02-03T23:09:00-06:00</updated>
    <id>http://jessecravens.com/blog/2013/02/03/html5-dot-tx-2013</id>
    <content type="html"><![CDATA[<h3>Embedded JavaScript, HTML5 and the Internet of Things</h3>

<script async class="speakerdeck-embed" data-slide="46" data-id="92b31ab050b501308fcd1231381d555c" data-ratio="1.2994923857868" src="http://jessecravens.com//speakerdeck.com/assets/embed.js"></script>


<p>I had a great time presenting at HTML5.tx 2013, here is an embed above of the slide deck. I should have the trailr node module in a presentable format soon and I'll tweet its inclusion in NPM. I have a placeholder here: <a href="https://npmjs.org/package/trailr">trailr at npm</a>.</p>

<p>I also pushed out the version 1 trailr-admin UI here: <a href="http://trailr-admin.herokuapp.com/dashboard">trailr-admin.herokuapp.com</a>.</p>

<p>Very soon, initial documentation will be available at: <a href="http://trailr.io">trailr.io</a></p>

<p><img class="" alt=""  src="http://jessecravens.com/images/html5tx2013/embedded.JPG">
Photo credit: Mitch Fincher: <a href="http://mitchfincher.blogspot.com/2013/02/pictures-from-html5tx-2013-in-austin-tx.html">mitchfincher.blogspot.com</a></p>

<p><img class="" alt=""  src="http://jessecravens.com/images/html5tx2013/embedded2.JPG">
Photo credit: Mitch Fincher: <a href="http://mitchfincher.blogspot.com/2013/02/pictures-from-html5tx-2013-in-austin-tx.html">mitchfincher.blogspot.com</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Build a Milestone Calendar with IndexedDB and FullCalendar.js]]></title>
    <link href="http://jessecravens.com/blog/2013/01/17/build-a-milestone-calendar-with-indexeddb-and-fullcalendar-dot-js/"/>
    <updated>2013-01-17T08:47:00-06:00</updated>
    <id>http://jessecravens.com/blog/2013/01/17/build-a-milestone-calendar-with-indexeddb-and-fullcalendar-dot-js</id>
    <content type="html"><![CDATA[<h4>IndexedDB is a persistent object data store in the browser. Although it is not a full SQL implementation and it is more complex than the unstructured key–value pairs in localStorage, you can use it to define an API that provides the ability to read and write key–value objects as structured JavaScript objects, and an indexing system that facilitates filtering and lookup.</h4>

<p>For this hack we will use IndexedDB to store milestone objects for a calendar application. The UI will provide a simple means to create a new milestone and provide a title, start date, and end date. The calendar will then update to show the contents of the local data store. Figure 6-8 shows the result.</p>

<p>Figure 6-8. FullCalendar.js and IndexedDB</p>

<p><img class="figure" alt="Figure 6-8" src="http://jessecravens.com/images/chapter6-images/6-8.png"></p>

<p>We need to start by including the markup for the two pieces of the UI: the calendar and the form.
We’ll begin with the form. You may notice that the input fields for the dates include data-date-format attributes. We will use these later for the JavaScript date pickers.</p>

<p>{% codeblock milestone form %}
 <form></p>

<pre><code> &lt;fieldset&gt;

   &lt;div class="control-group"&gt;
     &lt;label class="control-label"&gt;Add a Milestone&lt;/label&gt;
     &lt;div class="controls"&gt;
       &lt;h2&gt;New Milestone&lt;/h2&gt;
       &lt;input type="text" name="title" value=""&gt;
       &lt;input type="text" class="span2" name="start"
         value="07/16/12" data-date-format="mm/dd/yy" id="dp1" &gt;
       &lt;input type="text" class="span2" name="end"
         value="07/17/12"  data-date-format="mm/dd/yy" id="dp2" &gt;
     &lt;/div&gt;
   &lt;/div&gt;

   &lt;div class="form-actions"&gt;
      &lt;button type="submit" class="btn btn-primary"&gt;Save&lt;/button&gt;
      &lt;button class="btn"&gt;Cancel&lt;/button&gt;
   &lt;/div&gt;

  &lt;/fieldset&gt;
</code></pre>

<p> </form>
{% endcodeblock %}</p>

<p>The calendar is provided by <a href="http://arshaw.com/fullcalendar/">FullCalendar.js</a>, a fantastic jQuery plug-in for generating robust calendars from event sources. The library will generate a calendar from a configuration object and a simple div.</p>

<p>{% codeblock simple div %}</p>

<div id='calendar'></div>


<p>{% endcodeblock %}</p>

<p>And we can’t forget to include a few dependencies:</p>

<p>{% codeblock CSS and JavaScript dependencies %}
<link href="../assets/css/datepicker.css" rel="stylesheet">
<link href="../assets/css/fullcalendar.css" rel="stylesheet"></p>

<script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>


<script src="../assets/js/bootstrap-datepicker.js"></script>


<script src="../assets/js/fullcalendar.min.js"></script>


<p>{% endcodeblock %}</p>

<p>To improve the user experience, we will also include date pickers for choosing the dates within the form fields for start and end dates (see Figure 6-9).</p>

<p>Figure 6-9. Date pickers</p>

<p><img class="figure" alt="Figure 6-9" src="http://jessecravens.com/images/chapter6-images/6-9.png"></p>

<p>To instantiate the date pickers we will include the following toward the beginning of our script:</p>

<p>{% codeblock instantiate the date pickers %}
$(function(){</p>

<pre><code>$('#dp1').datepicker();
$('#dp2').datepicker();
</code></pre>

<p>  });
{% endcodeblock %}</p>

<h3>The Milestone IndexedDB</h3>

<p>Now we will set up a global namespace to hold our code, and set up a public milestones array (within the namespace) to hold our milestones temporarily while we pass them between our database and the FullCalendar API. This should make more sense as you continue to read. While we are at it we will need to normalize our indexedDB variable across all of the vendor-specific properties.</p>

<p>{% codeblock namespace and normalize %}
var html5hacks = {};</p>

<p>html5hacks.msArray = [];</p>

<p>var indexedDB = window.indexedDB || window.webkitIndexedDB ||</p>

<pre><code>            window.mozIndexedDB;
</code></pre>

<p>if ('webkitIndexedDB' in window) {
  window.IDBTransaction = window.webkitIDBTransaction;
  window.IDBKeyRange = window.webkitIDBKeyRange;
}
Now we can begin to set up our database:
html5hacks.indexedDB = {};
html5hacks.indexedDB.db = null;</p>

<p>function init() {
  html5hacks.indexedDB.open();
}</p>

<p>init();
{% endcodeblock %}</p>

<p>This will obviously fail for now, but as you can see the initialization begins by calling the open() method on an html5hacks.indexedDB. So let’s take a closer look at open():</p>

<p>{% codeblock open() %}
html5hacks.indexedDB.open = function() {</p>

<p>  var request = indexedDB.open("milestones");</p>

<p>  request.onsuccess = function(e) {</p>

<pre><code>var v = "1";
html5hacks.indexedDB.db = e.target.result;

var db = html5hacks.indexedDB.db;

if (v!= db.version) {
  var setVrequest = db.setVersion(v);
  setVrequest.onerror = html5hacks.indexedDB.onerror;

  setVrequest.onsuccess = function(e) {
    if(db.objectStoreNames.contains("milestone")) {
      db.deleteObjectStore("milestone");
    }

    var store = db.createObjectStore("milestone",
      {keyPath: "timeStamp"});

    html5hacks.indexedDB.init();
  };
}
else {
  html5hacks.indexedDB.init();
}
</code></pre>

<p>  };
  request.onerror = html5hacks.indexedDB.onerror;
}
{% endcodeblock %}</p>

<p>First, we need to open the database and pass a name. If the database successfully opens and a connection is made, the onsuccess() callback will be fired.</p>

<p>Within the onsuccess, we then check for a version and call setVersion() if one does not exist. Then we will call createObjectStore() and pass a unique timestamp within the keypath property.</p>

<p>Finally, we call init() to build the calendar and attach the events present in the database.</p>

<p>{% codeblock onsuccess() %}
html5hacks.indexedDB.init = function() {</p>

<p>  var db = html5hacks.indexedDB.db;
  var trans = db.transaction(["milestone"], IDBTransaction.READ_WRITE);
  var store = trans.objectStore("milestone");</p>

<p>  var keyRange = IDBKeyRange.lowerBound(0);
  var cursorRequest = store.openCursor(keyRange);</p>

<p>  cursorRequest.onsuccess = function(e) {</p>

<pre><code>var result = e.target.result;

if(!result == false){

    $('#calendar').fullCalendar({
      header: {
        left: 'prev,next today',
        center: 'title',
        right: 'month,agendaWeek,agendaDay'
      },
      weekmode: 'variable',
      height: 400,
      editable: true,
      events: html5hacks.msArray
    });

  return;

}else{

  console.log("result.value" , result.value);
  buildMilestoneArray(result.value);
  result.continue();
}
</code></pre>

<p>  };
  cursorRequest.onerror = html5hacks.indexedDB.onerror;
};</p>

<p>{% endcodeblock %}</p>

<p>At this point we are poised to retrieve all the data from the database and populate our calendar with milestones.
First, we declare the type of transaction to be a READ_WRITE, set a reference to the datastore, set a keyrange, and define a cursorRequest by calling openCursor and passing in the keyrange. By passing in a 0, we ensure that we retrieve all the values greater than zero. Since our key was a timestamp, this will ensure we retrieve all the records.</p>

<p>Once the onsuccess event is fired, we begin to iterate through the records and push the milestone objects to buildMilestoneArray:</p>

<p>{% codeblock buildMilestoneArray() %}
function buildMilestoneArray(ms) {
  html5hacks.msArray.push(ms);
}
When we reach the last record, we build the calendar by passing a configuration object to fullCalendar() and returning:</p>

<pre><code>    $('#calendar').fullCalendar({
      header: {
        left: 'prev,next today',
        center: 'title',
        right: 'month,agendaWeek,agendaDay'
      },
      weekmode: 'variable',
      height: 400,
      editable: true,
      events: html5hacks.msArray
    });

  return;
</code></pre>

<p>{% endcodeblock %}</p>

<h3>Adding Milestones</h3>

<p>Now that we are initializing and building our calendar, we need to begin adding milestones to the database via the form. First let’s use jQuery to set up our form to pass a serialized data object to addMilestone() on each submission:</p>

<p>{% codeblock form submit %}
  $('form').submit(function() {</p>

<pre><code>var data = $(this).serializeArray();

html5hacks.indexedDB.addMilestone(data);
return false;
</code></pre>

<p>  });
{% endcodeblock %}</p>

<p>Now let’s submit a few events and then view them in the Chrome Inspector to ensure they are there (see Figure 6-10).</p>

<p>Figure 6-10. Viewing milestone objects in the Chrome Inspector</p>

<p><img class="figure" alt="Figure 6-10" src="http://jessecravens.com/images/chapter6-images/6-10.png"></p>

<p>Let’s take a closer look at our addMilestone method:</p>

<p>{% codeblock addMilestone() %}
html5hacks.indexedDB.addMilestone = function(d) {
  var db = html5hacks.indexedDB.db;
  var trans = db.transaction(["milestone"], IDBTransaction.READ_WRITE);
  var store = trans.objectStore("milestone");</p>

<p>  var data = {</p>

<pre><code>"title": d[0].value,
"start": d[1].value,
"end": d[2].value,
"timeStamp": new Date().getTime()
</code></pre>

<p>  };</p>

<p>  var request = store.put(data);</p>

<p>  var dataArr = [data]
  request.onsuccess = function(e) {</p>

<pre><code>$('#calendar').fullCalendar('addEventSource', dataArr);
</code></pre>

<p>  };</p>

<p>  request.onerror = function(e) {</p>

<pre><code>console.log("Error Adding: ", e);
</code></pre>

<p>  };
};
{% endcodeblock %}</p>

<p>We established our read/write connection in much the same way as our html5hacks.indexedDB.init(), but now, instead of only reading data, we write a data object to the data store each time by calling store.put() and passing it data. On the onsuccess we then can call fullcalendar’s addEventSource() and pass it the data wrapped in an array object. Note that it is necessary to transform the data object into an array since that is what the FullCalendar API expects.</p>
]]></content>
  </entry>
  
</feed>
